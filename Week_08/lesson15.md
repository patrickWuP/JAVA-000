###为什么要做数据库拆分
1、单机数据库无法再满足业务需求。

2、单个库容量变小，多个库IO处理能力上升。

3、缺点拆开后带来相对应的业务复杂度，根据分库分表的方式做对应解决方案。

####单机数据库已经无法适应互联网的发展

业务飞速发展导致了数据规模的急速膨胀，单机数据库已经无法适应互联网业务的发展

传统的将数据集中存储至单一数据节点的解决方案，在容量、性能、可用性和运维成本这三方面已经难于满足互联网的海量数据场景。我们在单库单表数据量超过一定容量水位
的情况下，索引树层级增加，_**磁盘IO也很可能出现压力**_，会导致很多问题。

从性能方面来说，由于关系型数据库大多采用B+树类型的索引，在数据量超过阈值的情况下，索引深度的增加也将使得磁盘访问的IO
次数增加，进而导致查询性能的下降；同时，高并发访问请求也使得集中式数据库成为系统的最大瓶颈。

从可用性的方面来讲，服务化的无状态类型，能够达到较小成本的随意扩容，这必然导致系统的最终压力都落在数据库之上。
而单一的数据节点，或者简单的主从架构，已经越来越难以承担。从运维成本方面考虑，当一个数据库实例中的数据达到阈值
以上，数据备份和恢复的时间成本都将随着数据量的大小而愈发不可控。

几个例子

1、无法执行DDL，比如添加一列，或者增加索引，都会直接影响线上业务，导致长时间的数据库无响应。

2、无法备份，与上面类似，备份会自动先lock数据库的所有表，然后处理数据，量大了就没法执行了。

3、影响性能与稳定性，系统越来越慢，随时可能会出现主库延迟高，主从延迟很高，且不可控，对业务系统有极大的破坏性影响。

mysql dump 会锁表后再进行操作。


主从结构解决了高可用，读扩展，但是单机容量不变，单机写性能无法解决。

提升容量-->分库分表，分布式，多个数据库，作为数据分片的集群提供服务。

降低单个节点的写压力

提升整个系统的数据容量上限。

扩展立方体

X轴：通过clone整个系统复制，集群

Y轴：通过解耦不同功能复制，业务拆分

Z轴：通过拆分不同数据扩展，数据分片

>数据库/数据的扩展

全部数据 -> 数据复制 -> 主从结构、备份与高可用

业务分类数据 -> 垂直分库分表 -> 分布式服务化、微服务

任意数据 -> 水平分库分表 -> 分布式结构、任意扩容

###数据库垂直拆分

垂直拆分-以淘宝的服务化为例

垂直分库分表 => 分布式服务化 => 微服务架构

以淘宝系统架构为例 说明。

1、服务不能复用。

2、连接数不够。

mysql获取连接是bio的方式，会出现to many connect 问题。

>拆库

垂直拆分（拆库）：将一个数据库，拆分成多个提供不同业务数据处理能的数据库。

例如拆分所有订单的数据和产品的数据，变成两个独立的库，这个方式对业务系统有极大的影响，因为数据结构本身发生了变化，SQL
和关联关系也必随之发生了改变。原来一个复杂SQL直接把一批订单和相关的产品都查了出来，现在这个SQL不能用了，得改写SQL和程序。
先查询订单库数据，拿到这批订单对应的所有产品id，再根据产品id集合去产品库查询所有的产品信息，最后在业务代理里进行组装。

对业务系统影响较大，复杂sql不能使用，SQL执行次数变多，但平衡利弊拆库就得容忍带来的负面问题。

>拆表

垂直拆分（拆表）：如果单表数据量过大，还可能需要对单表进行拆分。

比如一个200列的订单主表，拆分成十几个子表：订单表、订单详情表、订单收件信息表、订单支付表、订单产品快照表等等。
这个业务系统的影响有时候可能会大到跟新做一个系统差不多。对于一个高并发的线上生产系统进行改造，就像是给心脑血管做手术，
动的愈多，越核心，出现大故障的风险越高。所以，我们一般情况下，尽量少用这种办法。

>垂直拆分的优缺点

1、单库（单表）变小，便于管理和维护

2、对性能和容量有提升作用

3、改造后，系统和数据复杂度降低

4、可以作为微服务改造的基础

1、库变多，管理变复杂

2、对业务系统有较强的侵入性

3、改造过程复杂，容易出故障

4、拆分到一定程度就无法继续拆分

>垂直拆分的一般做法

1、梳理清楚拆分范围和影响范围

2、检查评估和重构影响到的服务

3、准备新的数据库集群复制数据

4、修改系统配置并发布新版上线

注意：

1、先拆分系统，还是先拆分数据库？

2、先拆分多大范围？

>什么是水平拆分

水平分库分表

分为，分库、分表、分库分表三类

有什么区别？

>数据库水平拆分

水平拆分（按主键分库分表）：水平拆分就是直接对数据进行分片，有分库和分表两个具体方式，但是都只是降低单个节点数据量，但不改变数据本身的结构。
这样对业务系统本身的代码逻辑来说，就不需要做特别大的改动，甚至可以基于一些中间件做到透明。

比如把一个10亿条记录的订单单库单表（orderDB库 t_order表）。我们按照用户id除以32取模，把单库拆分成32个库orderDB_00..31;再按订单id除以32
取模,每个库里再拆分成32个表t_order_00_31。这样一共是1024个子表，单个表的数据量就只是100万条了。
一个查询如果能够直接路由到某个具体的子表，比如orderDB05.t_order_10，那么查询效率就会高很多。

默认情况下要带上分片键，否则全局查询要查1024个表再进行聚合。一次查询变成1024个sql。

水平拆分（按时间分库分表）：很多时候，我们的数据是有时间属性的，所以自然可以按照时间维度拆分。比如当前数据表和历史数据表，甚至按季度，按月，按天来
划分不同的表。这样我们按照时间维度来查询数据时，就可以直接定位到当前的这个子表。

强制按条件指定分库分表：比如配置好某些用户的数据进入单独的库表，其他数据默认处理。

自定义方式分库分表：指定某些条件的数据进入到某些库或表。

思考一个问题：

为什么有些DBA不建议分表，只建议分库？
（一些中间件，也只支持分库，不能分表）

1、分表不解决容量的问题，IO的问题。

2、可以用分库代替分表。

>分库还是分表，如何选择

一般情况下，如果数据本身的读写压力比较大，磁盘IO已经成为瓶颈，那么分库比分表要好。分库将数据分散到不同的数据库实例，使用不同的磁盘，从而可以并行
提升整个集群的并行数据处理能力。相反的情况下，可以尽量多考虑分表，降低单表的数据量，从而减少单表操作的时间，同时也能在单个数据库上使用并行操作
多个表来增加处理能力。


分库分表有什么缺点：

1、解决容量问题

2、比垂直拆分对系统影响小（前提是有合理的框架和中间件，否则影响也不小）

3、部分提升性能和稳定性

1、集群规模大，管理复杂

2、复杂SQL支持问题（业务侵入性，性能）

3、数据迁移问题，要把数据打散

4、一致性问题，尽量把一个事务要操作的表放到一个库里。

例子：如果按照买家id/orderId进行的分库分表，按照买家id进行查询就很方便

但按照sell_id查询：

1、执行1024个表的操作，再聚合。

2、用某种数据同步的方式以sell_id/orderId进行分库分表（或者不进行分库分表）。京东或淘宝同时有几套库，异构的数据库。

异构：

1、不同库的复制，mysql -> oracle。

2、库和表的整体规则不一样，具体到某张表的结构是一样的。

3、表结构不同。

以ShardingSphere-Proxy为例。

按用户分库，按订单分表（）；

思考一下，分库分表条件写成：

分库 user_id % 2

分表 user_id % 2

会发生什么？

