1.自己创建一个ServerSocket然后使用sb进行压测(环境为 win10 x64jdk1.8 parallel -Xms2g -Xmx2g)
sb -u http://localhost:8808/ -c 20 -N 60
         
                  RPS		 
单线程            46.1

创建新的线程      694

线程池(20/50)     762/750        

五种IO模型
       
	   阻塞          非阻塞
同步   阻塞I/O模型   非阻塞I/O模型
同步   I/O复用模型   信号驱动的I/O模型

					 异步I/O模型       异步	
					 
阻塞和非阻塞、同步和异步的关系：同步和异步是通信方式，阻塞和非阻塞式线程处理模型。
同步和异步的区别：主要差别是异步通过回调函数发起结果处理和发起请求的线程不是同一个。类比平台充值的回调函数操作。

同步和非阻塞：主线程执行时，多个任务拆分给多个子线程去处理，主线程继续往下主业务流程，如果依赖子线程处理后的数据，则需要等子线程处理完成返回结果再在主线程中处理。

非阻塞式I/O模型：和阻塞IO类比，内核会立即返回，返回后获得足够的CPU时间继续做其他的事情。
				 用户进程第一个阶段不是阻塞的，需要不断的主动询问kernel数据好了没有；第二个阶段依然总是阻塞的。	

I/O复用模型：在单个线程里同时监控多个套接字，通过select或poll轮询所有负责的socket，当某个socket有数据到达了，就通知用户进程。
			 IO复用通非阻塞IO本质一样，不过利用了新的selct系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。
			 进程先是阻塞在select/poll上，再是阻塞在读操作的第二个阶段上。
selct/poll的几大缺点：
（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大。
（2）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大。
（3）select支持的文件描述符数量太小了，默认是1024。
epoll（Linux 2.5.44内核中引入，2.6内核正式引入，可被用于代替POSIX select和poll系统调用）：想要IO效率好，系统对IO模型的支持也很重要。
（1）内核与用户空间共享一块内存。这样fd拷贝开销问题就得以解决。
（2）通过回调解决遍历问题。通过回调解决遍历大量的fd问题。
（3）fd没有限制，可以支撑10万连接。

信号驱动的I/O模型： 信号驱动IO与BIO和NIO最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。

异步式IO：异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后送信号告诉用户进程IO操作执行完毕（与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕）。

windows的IOCP模型

一个场景，去打印店打印文件。
同步阻塞：直接排队，别的啥也干不成，知道轮到你使用打印机了，自己打印文件。

epoll Reactor：拿个号码，回去该干嘛干嘛，等轮到你使用打印机了，店主通知你来用打印机，打印文件。

异步  Proactor：拿个号码，回去该干嘛干嘛，等轮到你使用打印机了，店主直接给你打印好文件，通知你来拿。


同步、异步对业务处理模式，根据需求选择对应的处理方式。现在绝大部分处理方式都是同步的。

阻塞、非阻塞是对应线程处理模式。

不同的库在不同的操作系统上api差别会相当的大，netty通过封装，屏蔽了这些问题。

WebSocket相当于在Http上做了一个hack，其本身支持长连接和二进制内容传输。