对象头和对象引用
在64位的JVM中，对象头占据的空间是12byte（8byte+4byte）对应Mark Word和类型指针的长度，这里的64位JVM默认压缩了指针长度为32位。
但是以8字节对齐，所以一个空类的实例至少占用16byte字节。

在32位的JVM中，对象头占据的空间是8byte（4byte+4byte）也是对应Mark Word和类型指针的长度。
以4字节对齐，所以一个空类的实例至少占用8byte字节。

通常在32位JVM，以及内存小于 -Xmx32g的64位JVM上（默认开启指针压缩），一个指针引用占用的内存默认是4个字节。

因此，64位JVM一般需要多消耗堆内存。

可以对比包装类型和原生类型，看看内存消耗的情况。以64位JVM(开启指针压缩)环境为例。
Integer：对象头（12字节） + 数据（4字节）
int：数据（4字节）
Integer比原生int多产生12字节的内存。
Long：对象头（12字节） + 数据（8字节）+ 对齐（4字节）
long：数据（8字节）
Long对原生long多产生16字节的内存。


多维数组：在二维数组int[dim1][dim2]中，每个嵌套的数组int[dim2]都是一个单独的Object，会额外占用16字节的空间。当数组维度更大时，这种开销特别明显。

int[128][2]实例占用3600字节。而int[256]实例则只占用1040字节。里面的有效存储空间是一样的，3600比起1040多了246%的额外开销。在极端情况下，byte[256][1],额外开销的比例是19倍！
[[I object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           7f a1 00 20 (01111111 10100001 00000000 00100000) (536912255)
     12     4        (object header)                           80 00 00 00 (10000000 00000000 00000000 00000000) (128)
     16   512     [I [[I.<elements>                            N/A
Instance size: 528 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total

Meta区存放的是class对象的基础信息



OutOfMemoryError:Unable to create new native thread
java.lang.OutOfMemoryError: Unable to create new native thread 错误是程序创建的线程数量已达到上限值的异常信息。

解决思路：
1.调整系统参数ulimit -a, echo 120000 > /proc/sys/kernel/threads-max
2.降低xss等参数
3.调整代码，改变线程创建和使用方式

JVM问题分析和调优经验
1、高分配速率（High Allocation Rate）
分配速率（Allocation rate）标识单位时间内分配的内存量。通常使用MB/sec作为单位。上一次垃圾收集之后，与下一次GC开始之前的年轻代使用量，两者的差值除以时间，就是分配速率。

分配速率过高就会严重影响程序的性能，在JVM中可能会导致巨大的GC开销。

正常系统：分配速率较低~回收速率 -> 健康
内存泄漏：分配速率 持续大于 回收速率 -> OOM
性能劣化：分配速率较高~回收速率 -> 亚健康

分配速率较高，会导致young区快速被填满。

new出来的对象会放到Eden去中。添加Eden区的容量，蓄水池变大。

最终的效果是，影响Minor GC的次数和时间，进而影响吞吐量。
在某些情况下，只要增加年轻代的大小，即可降低分配速率过高造成的影响，增加年轻代空间并不会降低分配速率，但是会减少GC的频率。如果每次GC有少量对象存活，minor GC的暂停时间就不会明显增加。

2、过早提升（Premature Promotion）
提升速率（promotion rate）用于衡量单位时间内从年轻代提升到老年代的数据量。一般使用MB/sec作为单位，和分配速率类似。

JVM会将长时间存活的对象从年轻代提升到老年代。根据分代假设，可能存在一种情况，老年代中不仅有存活时间长的对象，也可能有存活时间短的对象。这就是过早提升：对象存活时间还不够长的时候就被提升到了老年代。

major GC不是为频繁回收而设计的，但major GC现在也要清理这些生命短暂的对象，就会导致GC暂停时间过长。这会严重影响系统的吞吐量。


GC疑难情况问题分析
1、查询业务日志，可以发现这类问题：请求压力大，波峰，遭遇降级，熔断等等，基础服务、外部API依赖。
2、查看系统资源和监控信息：
硬件信息、操作系统平台、系统架构；
排查CPU负载、内存不足，磁盘使用量、硬件故障、磁盘分区用满、IO等待、IO密集、丢数据、并发竞争等情况；
排查网络：流量打满，相应超时，无响应，DNS问题，网络抖动，防火墙问题，物理故障，网络参数调整、超时、连接数。
3、查看性能指标，包括实施监控、历史数据。可以发现假死，卡顿、响应变慢等现象；
排查数据库，并发连接数、慢查询、索引、磁盘空间使用量、内存使用量、网络带宽、死锁、TPS、查询数据量、redo日志、undo、binlog日志、代理、工具BUG。可以考虑的优化包括：集群、主备、只读实例、分片、分区；
大数据，中间件，JVM参数。
4、排查系统日志，比如重启、崩溃、Kill。
5、APM，比如发现有些链路请求变慢等等。
6、排查应用系统
排查配置文件：启动参数配置、Spring配置、JVM监控参数、数据库参数、Log参数、APM配置
内存问题，比如是否存在内存泄漏，内存溢出、批处理导致的内存放大、GC问题等等；


实例经验:
物理机的CPU配置透传值docker容器中，GC误以为有48个线程可以工作，结果容器是4CPU内核，致使GC发生时，48个线程在4个CPU核心上发生资源竞争，导致大量的上下文切换。最终导致GC时间过长。


