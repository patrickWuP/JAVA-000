####读写锁 

ReadWriteLock管理一组锁，一个读锁，一个写锁。

读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。

所有读写锁的实现必须确保写操作对读操作的内存影响。每次只能有一个写线程，但是同时可以有多个线程并发地读数据。ReadWriteLock
适用于读多写少的并发情况。

####用锁的最佳实践

Doug Lea《Java并发编程：设计原则与模式》一书中，推荐的三个用锁的最佳实践，他们分别是：

1.永远只在更新对象的成员变量时加锁。

2.永远只在访问可变的成员变量时加锁。

3.永远不在调用其他对象的方法时加锁。

KK总结-最小使用锁：

1.降低锁范围：锁定代码的范围/作用域。

2.细分锁粒度：将一个大锁，拆分成多个小锁。

####无锁技术
核心实现原理：
1.volatile保证读写操作都可见(注意不保证原子);

2.使用CAS指令，作为乐观锁实现，通过自旋重试保证写入。

###解决分布式ID的方式
1.UUID

2.redis

3.雪花算法

4.分配id的集合，0 - 1000，下一个请求只能获取 1000 - 2000的id进行分配。

###什么是并发工具类
1、wait/notify

2、Lock/Condition

可以作为简单的协作机制。

更复杂的应用场景，比如

-我们需要控制实际并发访问资源的并发数量

-我们需要多个线程在某个时间同时开始运行

-我们需要指定数量线程达到某个状态再继续处理

所以我们需要并发工具类进行复杂场景的处理。

####AQS
AbstractQueueSynchronizer，既队列同步器。它是构建锁或者其他同步组件的基础（如Semaphore、CountDownLatch、ReentrantLock、ReentrantReadWriteLock），
是JUC并发包中的核心基础组件。

AbstractQueueSynchronizer：抽象队列式的同步器。

两种资源共享方式：独占|共享，子类负责实现公平 OR 非公平。

###Semaphore - 信号量
1.准入数量N

2.N=1则等价于独占锁

使用场景：同一时间控制并发线程数。

###CountdownLatch
场景：Master线程等待Worker线程把任务执行完

示例：等所有人干完手上的活，一起去吃饭。

###CyclicBarrier
场景：任务执行到一定阶段，等待其他任务对其。

示例：等待所有人都到达，再一起开吃。

####CountDownLatch 与 CyclicBarrie比较

减计数方式 | 加计数方式

计算为0时释放所有等待的线程 | 计数达到指定值释放所有等待线程

计数为0时，无法重置 | 计数达到指定值时，计数置为0重新开始

调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响 | 调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞

不可重复利用 | 可重复利用

